# Universidad de Puerto Rico en Humacao
## Departamento de Matemáticas

### A. Título del curso
Introducción a la Programación y la Ciencia de Cómputos II

### B. Codificación del Curso
COMP 3082

### C. Cantidad de créditos
3 horas contacto / 3 créditos

### D. Prerrequisitos, correquisitos y otros requerimientos
Prerequisitos: COMP 3081 - Introducción a la programación y ciencia de cómputos y COMP 3083 - Laboratorio de introducción a la programación y ciencia de cómputos.
Correquisitos: COMP3084 – Laboratorio de Introducción a la Programación y la Ciencia de Cómputos II.

### E. Descripción del Curso
En esta segunda parte del curso la estudiante profundiza en conceptos estudiados en la primera parte como la programación orientada a objetos (herencia, polimorfismo, clases abstractas, jerarquías de clases), el manejo de archivos (contenido no textual, archivos grandes), algunas estructuras de datos (composiciones de listas y diccionarios de objetos, tablas, búsquedas en cadenas) y los interfases gráficos de usuario. Además tendrá un primer contacto con el paradigma de la programación funcional, y la concurrencia.

### F. Objetivos de aprendizaje
Al terminar la discusión de cada sección del bosquejo de contenido del curso el o la estudiante podrá:

I. Introducción a tipos de datos abstractos y programación orientada a objetos
    1. Definir los términos tipo de dato abstracto, clase, objeto, estructura de datos y método e ilustrar con ejemplos las relaciones entre ellos.
    2. Implantar usando clases un tipo de dato abstracto coherente con un acoplamiento débil entre componentes y comportamientos.
    3. Evaluar la aplicabilidad a un problema de los tipos de datos abstractos lista, diccionario, vector, arreglo, serie y tabla.
    4. Reconocer la utilidad de las clases abstractas para definir el comportamiento general de sus subclases.
    5. Derivar nuevas excepciones de excepciones de biblioteca y demostrar su uso.
    6. Explicar cómo las bibliotecas estándar y herramientas de pruebas de unidades (unit tests) sirven para depurar código de aplicaciones.

II. Tipos de implantación de estructuras de datos
    1. Clasificar estructuras de datos como estáticas o dinámicas.
    2. Argumentar sobre las ventajas y desventajas de utilizar estructuras de datos estáticas o dinámicas para implantar una clase en particular.
    3. Contrastar los manejos recursivos en interactivos de una estructura de datos.
    4. Representar récords con clases y construir listas, diccionarios y tablas cuyas entradas sean récords.

III. Archivos
    1. Describir formatos de archivos de marcado (markup) e identificar sus usos.
    2. Explicar en principio cómo se puede discretizar señales análogas para almacenarlas en archivos digitales.
    3. Clasificar formatos comunes de digitalización de señales de imágenes o audio de acuerdo a si el método de compresión tiene pérdida o no (loosy vs. lossless).
    4. Adaptar estrategias de acceso a archivos al tamaño de los archivos a ser procesados.
    5. Evaluar el rendimiento de programas simples que manipulan archivos.
    6. Interpretar especificaciones de formato de archivos en función de extraer la información deseada de éstos.

IV. Serialización
    1. Añadir métodos de serialización y deserialización a una clase dada para escribir y recuperar su estado de un archivo.
    2. Describir cómo se puede usar módulos de biblioteca para dotar de persistencia a un objeto.
    3. Interpretar descripciones de formato JSON para recibir información de objetos serializados.

V. Manejo de cadenas de caracteres y bytes
    1. Manipular cadenas de caracteres y bytes con métodos comunes a muchos lenguajes de programación.
    2. Leer y escribir expresiones regulares para definir patrones de búsqueda en textos.

VI. Programación funcional
    1. Identificar tipos de problemas apropiados para una solución con un paradigma funcional.
    2. Reconocer estructuras y objetos de biblioteca iterables.
    3. Construir estructuras iterables mediante comprensiones (comprehensions).
    4. Definir funciones lambda para aplicarlas a todos los elementos de un objetos iterables para obtener otro objeto iterable.
    5. Definir y aplicar las operaciones map, filter y reduce.

VII. Cómputos concurrentes
    1. Explicar cómo usar hebras de ejecución para hacer cómputos concurrentes.
    2. Escribir código que logre acopiar los resultados de los procesos ejecutados en distintas hebras de ejecución.
    3. Reconocer los problemas de sincronización asociados a la concurrencia.

VIII. Interfases gráficos de usuario (GUI)
    1. Enumerar widgets de uso común y sus significados
    2. Desplegar widgets mediante varios mecanismos de despliegue
    3. Definir manejadores para eventos y señales.
    4. Manejar ambientes de programación para editar GUIs para componer ventanas y diálogos gráficos.

### G. Bosquejo del Contenido y Distribución de Tiempo

I. Tipos de Datos Abstractos y programación orientada a objetos (6 horas¹)
    1. Definición, estructuras de datos y operaciones sobre ellas
    2. Repaso: subclases, herencia, encapsulación
    3. Clases abstractas
    4. Polimorfismo, herencia múltiple, diagramas UML
    5. Excepciones: de biblioteca y subclases definidas por la programadora
    6. Unidades de prueba (Unit test)

II. Tipos de implantación de estructuras de datos (3 horas)
    1. Implantación estática usando arreglos y tablas.
    2. Implantación dinámica usando listas ligadas.
    3. Manejo iterativo o recursivo.
    4. Noción de récord y su implantación usando estructuras o clases.

III. Archivos (9 horas)
    1. Repaso: Archivo de texto vs. binario y sus modos de acceso: lectura, escritura, lectura/escritura, re-escritura, anexar.
    2. Flujo (stream)
    3. Funciones para manipular archivos. Texto: get, getline, put, >>, <<, formatos para insumo o producto. Binario: read, write.
    4. Posición en el archivo: apuntador de archivo, fin de archivo y función eof, seek, tell.
    5. Mecanismos de acceso a datos que no están en el disco físico de la computadora pero se manejan como archivos (ejemplo: archivos emulados, periferales, lectura de páginas web).
    6. Directorios – cartapacios.
    7. Estándares de codificación en binario: texto (ASCII, Unicode), números enteros y flotante (con y sin signo, distintas precisiones).
    8. Lenguajes de marcado: HTML, XML, TeX.
    9. Imágenes: mapa de bits, comprimidos (jpeg) e indizados (gif).
    10. Sonido
    11. Cargado a memoria vs procesado durante lectura
    12. GUI para selección de archivos.

IV. Serialización (3 horas)
    1. Serialización manual de objetos definidos por la programadora
    2. Serialización dependiente del lenguaje (pickle)
    3. JSON

V. Manejo de cadenas de caracteres y bytes (3 horas)
    1. Manejo con métodos de cadenas de caracteres (string)
    2. Expresiones regulares

VI. Programación funcional (6 horas)
    1. Definición y usos
    2. Iteradores y generadores
    3. Comprensiones
    4. Funciones lambda
    5. Operaciones tipo Map, Filter, Reduce
    6. Filtrado remoto (MapReduce, etc.)

VII. Cómputos concurrentes (4 horas)
    1. Hebras de ejecución (thread)
    2. Operaciones join, isAlive, temporizadores
    3. Sincronización

VIII. Fundamentos de Interfaces de usuario gráficos (GUI) (6 horas)
    1. Metáforas de interacción (widgets)
    2. Formatos de despliegue (layout)
    3. Eventos, señales y sus manejadores
    IX. Ambientes de programación para editar GUIs (QtDesigner)

La suma de las horas sugeridas es de 40. Las cinco horas restantes serán utilizadas para la ejecución evaluaciones y estrategias instruccionales afines con el curso (ver sección H). Los tópicos en este bosquejo de contenido son apropiados para ser ordenados de otras maneras a juicio del docente que imparta el curso en el ejercicio de su libertad de cátedra.

> ¹ Una hora contacto equivale a 50 minutos

### H. Técnicas Instruccionales
Con miras a lograr los objetivos del curso el o la profesora seleccionará entre las siguientes técnicas instruccionales: conferencias, videos, demostraciones, trabajos en grupo, estudios independientes, discusión de asignaciones. Además el profesor o profesora podrá implantar y fomentar otras actividades afines al curso.

### I. Recursos de aprendizaje e instalaciones mínimas disponibles o requeridos
La Universidad debe proveer un laboratorio para trabajo independiente de los estudiantes, el equipo electrónico que necesita el profesor para impartir la clase, el programado apropiado para el curso (Intérpretes y Compiladores de todos los lenguajes que se utilizarán, herramientas para el desarrollo de aplicaciones) y acceso a INTERNET. La o el estudiante deberá poseer una computadora portátil con capacidad de ejecutar los compiladores, intérpretes u otros programados utilizados en este curso. En caso de duda deberá consultar con el(la) profesor(a) del curso al comienzo del semestre.

### J. Técnicas de evaluación
Dos o más exámenes parciales, un examen final comprensivo y otros trabajos, a discreción del profesor, como asignaciones de programación y pruebas cortas Se sugiere que los exámenes constituyan un 60% de la nota final y los otros trabajos el 40%.

### K. Acomodo razonable
La Universidad de Puerto Rico (UPR) de Humacao reconoce el derecho que tienen los estudiantes con impedimentos a una educación post-secundaria inclusiva, equitativa y comparable. Conforme a la política de la Universidad de Puerto Rico hacia los estudiantes con impedimentos, fundamentada en la legislación protectora federal y local vigente en Puerto Rico, todo estudiante cualificado con impedimentos, tiene derecho a la igual participación de aquellos servicios, programas y actividades que están disponibles para la comunidad universitaria en general. Es decir, todo estudiante que tiene un impedimento de naturaleza física, mental o sensorial que lo limita sustancialmente en una o más actividades principales de la vida, podría tener derecho a recibir acomodos o modificaciones razonables en sus áreas de estudios.

Es importante que, de usted requerir algún tipo de acomodo o modificación razonable en este curso, deberá notificar al(a) profesor(a) de su necesidad de acuerdo a la condición física, mental o sensorial que presenta. Además, usted deberá visitar la Oficina de Servicios para Estudiantes con Impedimentos (OSEI) del recinto de Humacao para recibir orientación sobre los pasos que deberá seguir para solicitar acomodos o modificaciones razonables y de otros servicios de apoyo que le permitan la obtención de un adecuado aprovechamiento académico. Véase Certificación 133 (2015-2016) de la Junta de Gobierno de la UPR.

### L. Integridad académica
La Universidad de Puerto Rico promueve los altos estándares de integridad académica y científica. El Artículo 6.2 del Reglamento General de Estudiantes de la UPR (Certificación Número. 13, 2009-2010 de la Junta de Síndicos) establece que “la deshonestidad académica incluye, pero no se limita a: acciones fraudulentas, la obtención de notas o grados académicos valiéndose de falsas o fraudulentas simulaciones, copiar total o parcialmente la labor académica de otra persona, plagiar total o parcialmente el trabajo de otra persona, copiar total o parcialmente las respuestas de otra persona a las preguntas de un examen, haciendo o consiguiendo que otro tome en su nombre cualquier prueba o examen oral o escrito, así como la ayuda o facilitación para que otra persona incurra en la referida conducta” . Cualquiera de estas acciones estará sujeta a sanciones disciplinarias en conformidad con el procedimiento disciplinario establecido en el Reglamento General de Estudiantes de la UPR vigente.

### M. Sistema de calificación
Se adjudicará la calificación A, B, C, D, ó F según el nivel de competencia demostrado en las evaluaciones. El profesor o profesora podrá usar la escala 100-85 A, 84-75 B, 74-60 C, 59-50 D, 49-0 F u otra que resulte más apropiada para las calificaciones del curso e informará durante las primeras semanas de clases y en la guía de estudiante la curva a usarse para asignar las calificaciones.

### N. Bibliografía
1. ACM/IEEE-CS Task Group on Information Technology Curricula (2013). Information Technology Curricula 2017: Curriculum Guidelines for Baccalaureate Degree Programs in Information Technology. Final report, ACM Press and IEEE Computer Society Press. ISBN 978-1-4503-6416-4, DOI: 10.1145/3173161
2. Deitel, P. J., & Deitel, H. M. (2017). C++ how to program (10th ed.). upper saddle river: Pearson Education. ISBN 978-9332585737.
3. Deitel, H.M., Deitel, P.J. (2017). Java How to Program (early objects) (10th Edition) Prentice Hall. ISBN 978-0134743356.
4. Gaddis, T. (2017). Starting Out with C++: From Control Structures through Objects. (9th Ed.) Addison-Wesley Publishing Company. ISBN 978-0134498379.
5. Sotero Esteva, J. O. (2017). Introducción al Desarrollo de Aplicaciones Usando Scala. Manuscrito. Universidad de Puerto Rico en Humacao, Humacao, Puerto Rico.
6. Zelle, J. M. (2011). Python programming: an introduction to computer science. (3rd Ed.) Franklin, Beedle & Associates, Inc. ISBN 978-1590282755.

### O. Créditos
Preparado por José O. Sotero Esteva y revisado por Ollantay Medina, Elio Ramos e Idalyn Ríos el 10 de enero de 2019.

Algunos de estos objetivos han sido adaptados de las recomendaciones contenidas en el Information Technology Currícula 2017 de las organizaciones profesionales Association for computing Machinery y el Institute of Electrical and Electronic Engineers – Computer Society (ver bibliografía).

Este prontuario es propiedad de la Universidad de Puerto Rico. Sin embargo, su contenido es una creación académica de su autor. Por consiguiente, en el caso de uso de porciones significativas del mismo se espera reconocimiento del autor tal y como se ha hecho en esta sección.

Este bosquejo y los objetivos específicos que le preceden cubren las siguientes unidades de conocimiento de las recomendaciones curriculares Information Technology Curricula 2017 de las organizaciones profesionales ACM e IEEE-Computing Society según la siguiente tabla:

| Dominio de conocimiento | Horas cubiertas | |
| :--- | :---: | :---: |
| | Nivel 1 | Nivel 2 |
| AR/Machine Level Representation of Data | | 3 |
| GV/Fundamental Concepts | 1 | |
| PL/Object-Oriented Programming | 3 | |
| SDF/Fundamental Programming Concepts | 1 | |
| SDF/Fundamental Data Structures | 9 | |
| SDF/Algorithms and Design | 4 | |
| SE/Software Processes | 2 | |
